---
title: "Introduction to Theoretical Machines"
description: "Exploring theory of computation with Python"
date: "2025-08-25"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Theory of computation

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 

- {{< iconify fa6-solid lightbulb >}} **What is theory of computation?**
    - Understanding what can be computed
    - Analyzing computational complexity
    - Proving limits of computation
    - "Proofgrammers" combine *proofs* and *programming*

:::

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid lightbulb >}} **Why is it important?**
    - Helps determine if problems are solvable
    - Reveals fundamental computational limits
    - Guides key algorithm design choices
    - Undergirds modern cryptography and security

:::

## Becoming a proofgrammer

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid gear >}} **Master Python programming**
  - Implement theoretical concepts as code
  - Express mathematical proofs as programs
  - Analyze algorithmic complexity
- {{< iconify fa6-solid gear >}} **Understand computational theory**
  - Automata and formal languages
  - Decidability and undecidability
  - Complexity classes and reductions
- {{< iconify fa6-solid lightbulb >}} **Use programming to explore what can be computed!**

:::

## What does a proofgrammer do?

::: {.incremental style="margin-top: 0.1em; font-size: 0.9em;"}

- **Proofgrammer** =
  - **Proof** (mathematical verification) +
  - **Programming** (code implementation)
- Implement Turing machines and automata
- Prove undecidability results with Python code
- Analyze algorithmic complexity experimentally
- Create computational models of theoretical concepts
- Verify theoretical results through programming
- **Welcome to the proofgrammer team! How exciting!**

:::

## Define the `count_lines` function

```{python}
def count_lines(file_content: str) -> int:
    """Count the number of lines in the provided text content."""
    if not file_content:
        return 0
    lines = file_content.split('\n')
    return len(lines)
```

::: {.fragment style="margin-top: 0.25em; font-size: 0.9em;"}

- **Computable problems**: have clear, algorithmic solutions
- **Line counting**: decidable and tractable for any finite input
- **Function input**: various types of input strings possible
- **Important question**: what makes this problem computable?
- **Translate to uncomputable**: can you make this more difficult?
- {{< iconify fa6-solid lightbulb >}} **Differences in tractable, intractable, and uncomputable?**

:::

## Computable problems with Python

```{python}
# example source code content
sample_code = """def hello_world():
    print("Hello, Proofgrammers!")
    return True

def main():
    result = hello_world()
    print(f"Function executed: {result}")

if __name__ == "__main__":
    main()"""

# count lines in the sample code
line_count = count_lines(sample_code)
print(f"Number of lines in the sample code: {line_count}")
print(f"This is a computable problem - we can always determine the line count!")
```


## Try the `count_lines` function

```{pyodide}
#| autorun: true
#| max-lines: 10
def count_lines(file_content: str) -> int:
    """Count the number of lines in the provided text content."""
    if not file_content:
        return 0
    lines = file_content.split('\n')
    return len(lines)

# test with sample code
test_code = """def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(5))"""

line_count = count_lines(test_code)
print(f"Lines in Fibonacci code: {line_count}")
print("Try changing the code above to see the count change!")
```

::: {.fragment style="margin-top: 0.25em; font-size: 0.95em;"}

- This function accepts the source code of a program as input
- It processes the source code *without* running it directly

:::

## Universal computation with Python

```{pyodide}
#| autorun: true
#| max-lines: 10
def universal(prog_string: str, input_string: str) -> str:
    """Execute a program given as a string on the provided input."""
    local_namespace = {}
    exec(prog_string, {}, local_namespace)
    main_function = None
    for name, obj in local_namespace.items():
        if callable(obj) and not name.startswith('_'):
            main_function = obj
            break
    if main_function:
        return main_function(input_string)
    else:
        return "No function found"

# example program that checks if a string contains "GAGA"
contains_gaga_program = '''
def contains_gaga(input_str):
    """Check if the input string contains GAGA."""
    return "yes" if "GAGA" in input_str else "no"
'''

# demonstrate universal computation
test_string1 = "HELLO GAGA WORLD"
test_string2 = "programming"

# Example program that counts vowels
count_vowels_program = '''
def count_vowels(input_str):
    """Count the number of vowels in the input string."""
    vowels = "aeiouAEIOU"
    count = sum(1 for char in input_str if char in vowels)
    return str(count)
'''

print("Universal Computation in Action:")
print("================================")
print(f"Testing contains_gaga with '{test_string1}':")
result1 = universal(contains_gaga_program, test_string1)
print(f"Result: {result1}")

print(f"\nTesting count_vowels with '{test_string2}':")
result2 = universal(count_vowels_program, test_string2)
print(f"Result: {result2}")
```

## Let's discuss these examples!

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

- {{< iconify game-icons team-idea >}} **Key insights from these code examples:**
  - `universal`: demonstrates one program executing another program
  - **Universal computation** is central to general-purpose computers
  - Simple example to illustrate a powerful theoretical concept

:::

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

- {{< iconify game-icons team-idea >}} **Discuss in your teams:**
    - What makes the line counting problem computable?
    - Universal computation's relation to general-purpose computers?
    - What are the implications of programs executing programs?
    - What are the limits to implementing computer programs?

:::

# Don't assume it is possible to implement every Python program! Start to think like a proofgrammer!

## Computational challenges

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid gear >}} **Characterize computational problems**
  - What makes a problem computable or non-computable?
  - How do we measure algorithmic complexity?
  - What are the fundamental limits of computation?
- {{< iconify fa6-solid gear >}} **Compare and analyze algorithms**
  - Which approach is more efficient for large inputs?
  - How do we prove correctness of our implementations?
  - What tools help us understand computational behavior?

:::

## Theory of computation challenges

::: {.incremental}

- Abstract concepts require concrete implementations
- Proofs must be both rigorous and programmable
- Complexity analysis involves theory and experimentation
- Undecidability results challenge often intuition
- Think you finished a proof that is actually incorrect
- Connecting mathematical theory to practical programming
- **Make sure to regularly ask questions in Discord!**
- **Frequently schedule office hours with the instructor!**

:::

## Learn about theory of computation

:::: {.columns}

::: {.column width="50%"}

{{< iconify fa6-solid book-open >}} Explore the ["What Can be Computed"
textbook](https://whatcanbecomputed.com/) and [Python
documentation](https://docs.python.org/)

:::

::: {.column width="50%"}

{{< iconify fa6-brands github >}} Review computational examples like [WCBC
book](https://whatcanbecomputed.com/)'s code segments and slides

:::

::::

::: {.fragment .fade-down style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid lightbulb >}} **Key areas of focus**:
  - Python programming for theoretical concepts
  - Automata theory and formal languages  
  - Computational complexity and analysis
  - Decidability and undecidability proofs
  - Practical applications of theoretical machines

:::


## Essential tools

- Terminal window for command-line operations
- Git and GitHub for version control and collaboration
- VS Code for writing and testing Python code
- Uv for Python package and dependency management
- Quarto for creating interactive documents with code

::: {.fragment .fade .boxed-content style="margin-top: 0.25em; font-size: 0.9em;"}

{{< iconify fa6-solid microscope >}} How do we *implement* theoretical concepts
in code? How do we *verify* computational results? How do we *document* our
proofs effectively? How do we *apply* these insights to real-world problems?

:::


## Using AI in theoretical machines

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

- GitHub Copilot, Google Gemini CLI, or OpenCode assist with code:
  - Generated code theoretically correct and well-implemented?
  - Can the generated code help verify mathematical proofs?
  - Does the generated code follow programming best practices?
  - Can you integrate AI-generated code into your proof workflows?

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.1em; font-size: 0.8em;"}

{{< iconify fa6-solid lightbulb >}} Proofgrammers who use AI coding tools are
responsible for ensuring correctness, theoretical accuracy, and ethical use. Do
not assume that the explanation or a proof of a theoretical concept is correct.
**Although these tools can be helpful, you must use them with skepticism and
care.**

:::

# Let's set up your proofgramming environment!

- Classroom session on Tuesday
- Laboratory session on Tuesday
- Classroom session on Thursday

## Proofgramming environment

::: {.fragment style="margin-top: 0.1em; font-size: 0.9em;"}

- Terminal with command-line access for tool execution
- Version control system (Git with GitHub)
- Python development environment (UV + Python 3.12+)
- Code editor with syntax highlighting (VS Code + extensions)
- Documentation system (Quarto for interactive code/text)
- Assistants (GitHub Copilot, Google Gemini CLI, OpenCode)
- **Make sure that every member of your team for the first presentation can
effectively setup and use all of these tools!**
- **Schedule office hours with the course instructor for help!**

:::

## Development environment setup

- **Installing** essential tools for prosegrammers
- **Configuring** development environment for proofgramming
  - Complete these tasks during the first and second weeks
  - All skill-check and examinations assume working setup
  - Please attend the **SOS Week** events to learn more
  - Work with instructor and student technical leaders
  - Don't hesitate to regularly ask questions in Discord
  - Keep working and don't give up with setup tasks

## Essential tools for proofgrammers

::: {.fragment .callout-note icon=true title="Tips for effective theoretical machines setup"}

- [Git](https://git-scm.com/), [GitHub](https://github.com/), [GitHub
Education](https://github.com/education), and [GitHub Student Developer
Pack](https://education.github.com/pack)
- [GitHub SSH
Keys](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)
and [GitHub CLI](https://cli.github.com/) command-line program for interaction
with GitHub
- Free GitHub Pro Subscription for [GitHub
Copilot](https://github.com/features/copilot)
- [VS Code](https://code.visualstudio.com/) or another suitable text editor
(e.g., [Zed](https://zed.dev/) or [Neovim](https://neovim.io/))
- [Quarto](https://quarto.org/) CLI and the Quarto plugin for your text editor
- [Uv](https://docs.astral.sh/uv/) for [Python](https://www.python.org/)
installation, virtual environment and dependency management
- Make sure that Uv has installed [Python](https://www.python.org/) 3.12 or
Python 3.13
- The suite of tools from the [Node Package Manager](https://www.npmjs.com/),
include [npm](https://www.npmjs.com/) and [npx](https://www.npmjs.com/)
- [OpenCode](https://opencode.ai/) and [Google Gemini
CLI](https://github.com/google-gemini/gemini-cli) for AI Coding Agents, runnable
with npx
- Terminal window (e.g., [Warp](https://www.warp.dev/)) for running all of the
aforementioned programs

:::

## GitHub student benefits and copilot

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid gear >}} **GitHub Student Developer Pack**
  - Free access to premium developer tools and services
  - Apply at [education.github.com](https://education.github.com/pack)
  - Requires verification with .edu email or student ID
- {{< iconify fa6-solid gear >}} **GitHub Copilot Pro for Students**
  - AI-powered code completion and generation
  - Free for verified students and educators
  - Integrates with VS Code and other editors
- {{< iconify fa6-solid lightbulb >}} **Why GitHub tools?** Essential for
collaboration!

:::

## Checking your proofgrammer setup

```bash
# Run these commands in your terminal window
git --version                   # Check Git installation
python --version                # Check Python (via UV)
quarto --version                # Check Quarto installation
code --version                  # Check VS Code installation
uv --version                    # Check UV package manager
```

::: {.fragment .fade style="margin-top: 0.5em; font-size: 0.9em;"}

- **Test each tool individually** before starting projects
- **Create a test document** with code and text to verify integration
- **Consult documentation** links when troubleshooting
- **Schedule office hours** with the course instructor
- **Visit office hours** with the student technical leaders
- {{< iconify fa6-solid rocket >}} **Have these setup by the end of this week**!

:::

## Coding Agents Use Node.js tools

```bash
# Install Node.js and npm from nodejs.org
# Then use npx to run tools without permanent installation
npx @google/generative-ai-cli --version  # Google Gemini CLI
npx opencode --version                   # OpenCode AI assistant
```

::: {.fragment .fade style="margin-top: 0.5em; font-size: 0.9em;"}

- **Node.js**: JavaScript runtime enabling AI-powered coding assistants
- **NPX**: Run packages without installing globally, keeps system clean
- **Runtime**: Use Node for delivery, may be built in another language
- **Testing**: Authentication with GitHub or Google and work with the coding
agent to determine whether or not a problem is tractable or intractable. Ask
the agent to explain one of the code segments from the book, without stating
whether or not the code is a correct.

:::

# Can you clone the course website to your laptop and run `quarto preview`? Output?

::: {.fragment .fade style="margin-top: 0em; font-size: 0.9em;"}

- Fork the website's repository for your team
- Commit your presentation materials
- Create a PR request and ask for its review

:::

## Overall proofgramming setup

::: {.fragment .callout-note icon=true title="Tips for effective theoretical machines setup"}

- Devote time outside class to installing and configuring tools
- Confirm that most tools work during the first lab session
- Successfully get all tools to work during the first lab session
- Create and render test documents with the provided examples
- Complete the first proofgrammer presentation on time
- Contribute to collaborative presentation projects
- Prepare for first proofgrammer charette session

- {{< iconify fa6-solid rocket >}} **Get ready for an exciting journey into theoretical machines!**
- {{< iconify fa6-solid lightbulb >}} **If you are having trouble, publicly ask for help on Discord!**

:::

## Goals of theory of computation course

::: {.fragment .fade style="margin-top: -0.15em; font-size: 0.85em;"}

- **Computational Implementation**:
  - Design and implement theoretical concepts as Python programs
  - Create frameworks for running proofs as Python programs
  - Test all aspects of implementations to ensure correctness
- **Communicate** theoretical insights through **code** and **documentation**
- **Explain** and **evaluate** insights during **presentation sessions**
- Participate in **charette sessions** to discuss and learn from each other
- **Key next steps**:
  - Review the [course schedule](../../schedule/index.qmd)
  - Study the [course syllabus](../../syllabus/index.qmd)

:::
