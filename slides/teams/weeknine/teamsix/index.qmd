---
title: "The LastTtoA Problem"
description: "Explore multiple solutions to the LastTtoA problem"
date: "2025-10-23"
date-format: long
author: Hemani Alaparthi, Benedek Kaibas, Miguel Orti Vila, Ritesh Ojha
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Introduction

::: {.fragment style="margin-top: -0.5em; font-size: 1em;"} 
- **Goal**: To implement and analyze the LastTtoA problem using multiple computation models and programming styles.
- **Problem**: Given a DNA string with symbols (e.g.,{A, C, T, G}), replace the last occurrence of 'T' with 'A'
- **Approaches**: Turing machine, Python (with/without regular expression(regex)), and another language.
:::


## The LastTtoA Function

::: {.fragment}
- **Input**: A string `s` that contains DNA symbols {A, C, T, G}

- **Output**: String `s'` where the last occurrence of 'T' is replaced with 'A'

**Examples**

- `ATCGT` → `ATCGA`
- `TTTT` → `TTTA` (last T becomes A)
- `ACGAA` → `ACGAA` (no T to replace)
- `T` → `A`
:::

## Implementation 1: Turing Machine

::: {.fragment style="font-size: 0.95em;"}
**Formal Components**:

- **States**: {q0, q1, qhalt}
- **Tape Alphabet**: {A, C, G, T, _}

**Two-Phase Algorithm**:

- **q0**: Scan right to find blank `_` → transition to q1
- **q1**: Scan left to find 'T' → replace with 'A' → halt

**Key Feature**: Explicit state machine matching formal TM definition
:::


## Implementation 2: Pure Python

::: {.fragment style="font-size: 0.9em;"}
**Algorithm** (No libraries, no regex):

1. **Initialize**: `last_t_index = -1`
2. **Scan forward**: Loop through entire string
   - Each time 'T' is found, update `last_t_index = i`
   - After loop completes, `last_t_index` holds position of last T
3. **Check**: If `last_t_index == -1`, no T exists → return unchanged
4. **Reconstruct**: `dna[:last_t_index] + 'A' + dna[last_t_index + 1:]`
:::

## Key Difference from TM

- Single forward pass vs. TM's two-phase scan (right then left)
- Direct string indexing vs. tape head movements
- Both achieve O(n) time complexity

## LastTtoA Turing Machine

![State Diagram](lastTtoA.png)

## Complete Computation of the LastTtoA Machine

![Complete Computation](lastTtoA_2.png){height=50%}

## LasttoA Turing Machine Example
```{pyodide}
def turing_lastTtoA(tape_input: str) -> str:
    # init the tape as a list of symbols + a blank at the end
    tape = list(tape_input) + ['_']
    head = 0
    state = 'q0'

    while state != 'qhalt':
        symbol = tape[head]

        # state q0: move right until we find a blank
        if state == 'q0':
            if symbol in {'A', 'C', 'G', 'T'}:
                head += 1
            elif symbol == '_':
                state = 'q1'
                head -= 1  # move left
            else:
                raise ValueError(f"Unexpected symbol: {symbol}")

        # state q1: move left until we find the last T
        elif state == 'q1':
            if symbol == 'T':
                tape[head] = 'A'
                state = 'qhalt'  # halt after replacement
            elif symbol == '_':
                # no T found, halt without changes
                state = 'qhalt'
            else:
                head -= 1  # move left

        # safety: make sure head never goes below zero
        if head < 0:
            state = 'qhalt'  # halt if we reach the beginning

    # return everything before the first blank
    return ''.join([s for s in tape if s != '_'])

print("ATCGT ->", turing_lastTtoA("ATCGT"))  # Expected: ATCGA
print("TTTT ->", turing_lastTtoA("TTTT"))    # Expected: TTTA
```

## LastTtoA using Pure Python
```{pyodide}
def lastTtoA_plain(dna: str) -> str:
    """Replace the last occurrence of 'T' with 'A' in the given DNA string."""
    # find the position of the last 'T'
    last_t_index = -1
    for i in range(len(dna)):
        if dna[i] == 'T':
            last_t_index = i

    # replace only if there was at least one 'T'
    if last_t_index == -1:
        return dna  # no change if no 'T'

    # construct a new string
    return dna[:last_t_index] + 'A' + dna[last_t_index + 1:]

print("ATCGT ->", lastTtoA_plain("ATCGT"))  # expected: ATCGA
```


## LastTtoA using Regex

```{pyodide}
#| autorun: true
#| max-lines: 15
"""Implementing LastTtoA function using regex."""
import re

def main(input_str: str):
    input = input_str.lower()
    last_t_position = -1
    search_for_t = r"t"
    found_t = re.finditer(search_for_t, input)
    last_match = None

    for find_t in found_t:
        last_match = find_t

    if last_match != None:
        last_t_position = last_match.start()
        output = input[:last_t_position] + 'a' + input[last_t_position+1:]
    else:
        output = input

    print(output)

main("ATCGT")
main("TTTT")
main("ACGAA")
main("T")
```

## Implement lastTtoA using C++

![CPP Sandbox](qrcode.png){height=50%}

## Implement lastTtoA using C++

```cpp
#include <iostream>
#include <algorithm>
#include <cctype>

std::string lower(std::string input) {
    std::transform(input.begin(), input.end(), input.begin(),
                [](unsigned char character){return std::tolower(character);});
    return input;
};

std::string lower_text = lower("ACTGT");

void lastTtoA() {
    std::string& input_string = lower_text;
    std::reverse(input_string.begin(), input_string.end()); // string reverse so first element is the last
    char const& replace_letter = 't';
    char const& replace_with = 'a';

    std::size_t position = input_string.find(replace_letter);
    if(position == std::string::npos) std::cout << "No letter T in the string: ";
    if(position != std::string::npos){
      input_string.replace(position, 1, 1, replace_with);
    }
    // The line below replaces every T found in the text
    //std::replace(input_string.begin(), input_string.end(), replace_letter, replace_with);
 
    // logic to re-reverse input string
    std::string normal_string;
    for (int i = input_string.length() - 1; i>= 0; --i) {
        normal_string += input_string[i];
    }
    std::cout << normal_string;
}

int main() {
    lastTtoA();
}
```

## Comprehensive Test Suite

```py
def test_all_implementations():
    test_cases = [
        ("ATCGT", "ATCGA"),      # Basic case
        ("ACGAA", "ACGAA"),      # No T's
        ("", ""),                # Empty string
    ]
    implementations = [
        ("Turing Machine", turing_lastTtoA),
        ("Pure Python", lastTtoA_plain),
        ("Regex Python", lastTtoA_regex)
    ]
    for name, func in implementations:
        print(f"\nTesting {name}:")
        for input_str, expected in test_cases:
            result = func(input_str)
            status = "✓" if result == expected else "✗"
            print(f"  {status} '{input_str}' → '{result}' (expected: '{expected}')")
```

## Test Results and Validation

::: {.fragment}
- **Testing Methodology**:
    - **Unit Testing**: Individual function validation
    - **Integration Testing**: Cross-implementation consistency
    - **Performance Testing**: Execution time comparison
    - **Edge Case Testing**: Boundary condition validation
:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}
**Key Finding**: All four implementations (TM, Pure Python, Regex, C++) produce identical outputs for identical inputs
:::

## Summary of implementations

::: {.fragment}

- **Deterministic Turing Machine**: Formal 3-state machine with transition function (q0 → q1 → qhalt, tape operations)
    - Example: `ATCGT⊔` → scan right → scan left → replace T → `ATCGA`

- **Pure Python**: We used Loop-based scanning with string slicing reconstruction

- **Python with Regex**: Implemented pattern matching to locate and process the last 'T' and transformation to 'A'

- **Non-Python Implementation**: Implemented algorithm in C++ using string reversal and pattern matching techniques
:::

## Conclusion

:::{.fragment}

- **Result**: All implementations produce `"ATCGT"` → `"ATCGA"`

- **Comprehensive Testing**: All implementations validated with identical test suites

- **Theoretical Analysis**: LastTtoA is **computable** and **tractable** (O(n))
:::

