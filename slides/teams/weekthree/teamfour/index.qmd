---
title: "DetectThrowsException Decision Problem"
description: "Explore the detection of exception throwing"
date: "2025-09-08"
date-format: long
author: Anoop Guragain, Duru Akbas, Joseph Oforkansi
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Introduction

## A simple exceptions "detection" program

- Takes an input that is a string containing source code
- Search through the source code line by line using regex for certain keys or pattern
- Add those lines that matches to a list called "warnings" with a message
- Convert that list into multi-line string and returns it

---

## To be noted

> - It does not detect, it just kind of predicts if the program is going to throw an exception.

> - It does not run the program or confirms that an exception will or won't occur.

> - It gives false positive and false negative such as it count comments and strings as the part of the source code

---

## Exceptions

- **Divisible by zero**

```python
 if re.search(r"/\s*0", line):
    warnings.append(f"Division by zero at line {i}")
```

- **Value error (int() and float())**

```python
  if "int(" in line or "float(" in line:
    warnings.append(f"Possible ValueError in conversion at line {i}")
```

- **Index error**

```python
  if re.search(r"\w+\[.*\]", line):
    warnings.append(f"Possible IndexError/KeyError at line {i}")
```

- **Raise**

```python
  if "raise " in line:
    warnings.append(f"Explicit raise at line {i}")
```

---

```{pyodide}
#| max-lines: 15
#| autorun: true

import re

def detect_exceptions(code: str) -> str:
    warnings = []
    lines = code.splitlines()

    for i, line in enumerate(lines, start=1):
        # Detect division by zero like 5/0 or 5 / 0
        if re.search(r"/\s*0", line):
            warnings.append(f"Division by zero at line {i}")
        # Detect int() and float() conversions
        if "int(" in line or "float(" in line:
            warnings.append(f"Possible ValueError in conversion at line {i}")
        # Detect indexing or dictionary access (possible IndexError/KeyError)
        if re.search(r"\w+\[.*\]", line):
            warnings.append(f"Possible IndexError/KeyError at line {i}")
        # Detect explicit raise statements
        if "raise " in line:
            warnings.append(f"Explicit raise at line {i}")

    return "\n".join(warnings) if warnings else "No obvious exception-causing patterns found"

# === Example Python code to analyze ===
code_to_check = """
x = 10 / 0
y = int("abc")
z = arr[5]
raise ValueError("manual raise")
"""

# Run the detector (SiSo style)
result = detect_exceptions(code_to_check)
print(result)



```

> - detect_exceptions function scans for risky patterns
> - Splits "code" into individual lines
> - Exception triggers are: division by zero, type conversions, indexing or dictionary access (opening and closing brackets and matches a word), explicit raise statements
> - Returns the warnings found
---

---

# Conclusion
- Our `DetectThrowsException` program is a heuristic demonstration of a decision problem. It cannot prove whether an exception will occur, but it offers a first step by flagging suspicious patterns in source code.
- This limitation connects to a fundamental idea in theoretical computer science: undecidability. Just as the halting problem shows no program can universally decide if another program will halt, no tool can perfectly predict all possible runtime exceptions
- While imperfect, our detector shows how even a simple pattern-matching approach can still provide practical value in software development, helping catch likely errors early without guaranteeing complete correctness. 
---
