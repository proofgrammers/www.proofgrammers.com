---
title: "PolyCheck and NPoly"
description: "Grasp the benefits of verification"
date: "2025-11-17"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Learning objectives

::: {.fragment .callout-note icon=true title="Learning Objectives for Theoretical Machines"}

- **CS-204-1**: Use both intuitive analysis and theoretical proof
techniques to correctly distinguish between problems that are tractable,
intractable, and uncomputable.
- **CS-204-2**: Correctly use one or more variants of the Turing machine
(TM) abstraction to both describe and analyze the solution to a
computational problem.
- **CS-204-3**: Correctly use one or more variants of the finite state
machine (FSM) abstraction to describe and analyze the solution to a
computational problem.
- **CS-204-4**: Use a formal proof technique to correctly classify a
problem according to whether or not it is in the P, NP, NP-Hard, and/or
NP-Complete complexity class(es).
- **CS-204-5**: Apply insights from theoretical proofs concerning the
limits of either program feasibility or complexity to the implementation
of both correct and efficient real-world Python programs.

:::

# PolyCheck and NPoly are about verification!

::: {.fragment .boxed-content style="font-size: 0.875em;"}

{{< iconify fa6-solid layer-group >}} **PolyCheck and NPoly** help with learning
objectives **CS-204-1** and **CS-204-4**. We will define two complexity classes
that capture problems whose solutions are **easy to verify** even if they're
**hard to find**. This chapter reveals a surprising result: these two classes,
defined in completely different ways, are identical! **As proofgrammers, let's
explore verification and nondeterminism to understand what can be efficiently
checked**. Okay, let's dive in!

:::

## Review: Poly and Expo classes

::: {.incremental style="margin-top: -0.25em; font-size: 0.8em;"}

- **Poly**: Problems solvable in polynomial time $O(n^k)$
- **Expo**: Problems solvable in exponential time $O(2^{n^k})$
- **Key relationship**: Poly $\subseteq$ Expo for computational complexity
- **Tractability**: Poly problems are feasible, Expo problems often are not
- **Examples**: Sorting in Poly, factoring in Expo (no known poly algorithm)
- **Question**: What about problems that are hard to solve but easy to check?

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**The Poly/Expo boundary separates tractable from intractable**: but some
problems are *easy to verify even when hard to solve*. For instance, factoring a
number is hard, but checking if a number is a factor is easy! **This observation
leads us to PolyCheck**! The word **Check** connects to "verification"!

:::

# Verifiers check proposed solutions

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid circle-check >}} **Verifier**: Program that checks
if a proposed solution is correct
- {{< iconify fa6-solid inbox >}} **Three inputs**: Instance $I$, proposed
solution $S$, hint $H$
- {{< iconify fa6-solid rocket >}} **Two outputs**: `correct` or `unsure`
(never `incorrect`!)
- {{< iconify fa6-solid lightbulb >}} **Key idea**: Verification can be
easier than solving
- {{< iconify fa6-solid microscope >}} **Example**: Checking factors is
easier than finding them

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **Verifiers formalize the notion of "easy to
check"**: given a proposed solution, can we quickly verify its correctness? The
asymmetry between positive and negative instances is crucial and connects to the
prior concept of nondeterminism!

:::

## Verifier for FACTOR problem

```{pyodide}
#| autorun: true
#| max-lines: 8
def verifyFactor(I, S, H):
    """Verify a proposed solution to the FACTOR problem."""
    if S == 'no':
        return 'unsure'
    M = int(I)
    m = int(S)
    if m >= 2 and m < M and M % m == 0:
        return 'correct'
    else:
        return 'unsure'

print(f"verifyFactor('1400', '200', '') = {verifyFactor('1400', '200', '')}")
print(f"verifyFactor('1400', '500', '') = {verifyFactor('1400', '500', '')}")
print(f"verifyFactor('20', '5', '') = {verifyFactor('20', '5', '')}")
```

::: {.fragment style="font-size: 0.8em;"}

- **Easy to verify**: Check if $m$ divides $M$ in polynomial time
- **Hard to find**: Finding factors requires searching many candidates
- **Note**: Returns `unsure` when the "quick check" is not clear

:::

## Why `unsure` not `incorrect`?

::: {.incremental style="margin-top: -0.25em; font-size: 0.825em;"}

- {{< iconify fa6-solid circle-question >}} **Two reasons for failure**:
    - Proposed solution $S$ is actually incorrect
    - Hint $H$ was wrong (even if $S$ is correct)
- {{< iconify fa6-solid ban >}} **Cannot distinguish**: No way to tell which
case occurred
- {{< iconify fa6-solid microscope >}} **Asymmetry**: Positive instances
verifiable, negative instances never are
- {{< iconify fa6-solid lightbulb >}} **Connection**: Similar to
nondeterministic computation!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**The `unsure` output reflects fundamental asymmetry**: verifiers can confirm
correctness but cannot definitively reject; they are "helpful" but not perfect.
This asymmetry mirrors nondeterministic computation where positive solutions are
found but negative instances only yield `no`!

:::

## Review of verification

![](12-polycheck-and-npoly_2.png)

::: {.fragment style="font-size: 0.85em;"}

- Verifier $V(I, S, H)$ receives instance $I$, solution $S$, and hint $H$
- Always halts, returning `correct` or `unsure`
- Positive instances verifiable with some correct $S$ and $H$
- Negative instances never verifiable, always return `unsure`

:::

## Diagrammatic view of verification

![](12-polycheck-and-npoly_5.png)

::: {.fragment style="font-size: 0.85em;"}

- **Top branches**: Positive instance with correct or incorrect solution
- **Bottom branch**: Negative instance always returns `unsure`
- **Asymmetry**: Only positive instances can return `correct`

:::

# Hints help verification

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"}

- {{< iconify fa6-solid lightbulb >}} **Hint string $H$**: Additional
information to help verification
- {{< iconify fa6-solid map >}} **Example**: For TSPD, hint provides the
Hamilton cycle
- {{< iconify fa6-solid rocket >}} **Efficiency**: Without hint, checking all
cycles takes exponential time
- {{< iconify fa6-solid circle-check >}} **With hint**: Simply verify the given
cycle in polynomial time
- {{< iconify fa6-solid microscope >}} **Key insight**: Hints make exponential
searches into polynomial checks

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Hints are the secret to efficient verification**: they tell us where the
needle is in the haystack, so we can quickly verify it's a needle without
searching the entire haystack. This makes verification much easier than solving!

:::

# Polytime verifiers run in polynomial time

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid stopwatch >}} **Polytime verifier**: Runs in
$O(n^k)$ time for instance length $n$
- {{< iconify fa6-solid ruler >}} **Crucial detail**: Only $|I|$ matters,
not $|S|$ or $|H|$
- {{< iconify fa6-solid shield >}} **Protection needed**: Must reject
excessively long $S$ and $H$
- {{< iconify fa6-solid lightbulb >}} **Why?**: Without this check,
processing long $S$ or $H$ could take exponential time, which defeats
the purpose of quick verification
- {{< iconify fa6-solid microscope >}} **Solution**: Reject if $|S| > |I|$
or $|H| > |I|$
- **Let's see what this would look like for FACTOR!**

:::

## Polytime verifier for FACTOR

![](12-polycheck-and-npoly_7.png)

::: {.fragment style="font-size: 0.85em;"}

- **Added check**: Reject if $|S| > |I|$ or $|H| > |I|$
- **Guarantees polynomial time**: Bounded by $|I|$
- **Same verification logic**: Otherwise identical to basic verifier

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Polytime verifiers must protect against long inputs**: if $S$ has length
$2n$, just converting it to an integer takes $2n$ steps, which is too expensive!

:::

## Formal definition of polytime verifier

![](12-polycheck-and-npoly_6.png)

::: {.fragment style="font-size: 0.85em;"}

- Verifier $V(I, S, H)$ must halt in polynomial time as function of $|I|$
- Lengths of $S$ and $H$ are irrelevant to running time bound
- This definition enables the PolyCheck complexity class

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

{{< iconify fa6-solid gears >}}  Can you intuitively see the benefits of
verification? Do you have a strong intuitive understanding of the concept of a
polytime verifier?

:::

# Efficient verification

::: {.incremental style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid layer-group >}} **PolyCheck**: Complexity class
containing problems whose positive instances can be verified in polynomial time
- {{< iconify fa6-solid check-circle >}} **Definition**: Problem $F \in$
PolyCheck if there exists a polytime verifier for $F$
- {{< iconify fa6-solid rocket >}} **Examples**: FACTOR, TSPD, PACKING,
SUBSETSUM, and PARTITION
- {{< iconify fa6-solid microscope >}} **Key insight**: Many problems have a
verification easier than solving
- {{< iconify fa6-solid lightbulb >}} **Practical meaning**: Solutions are hard
to find but easy to check

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**PolyCheck captures "easy to verify"**: these are problems where checking a
proposed solution is polynomial-time, even if finding the solution might be
exponential-time. This is the class of problems where verification helps!

:::

## Formal definition of PolyCheck

![](12-polycheck-and-npoly_8.png)

::: {.fragment style="font-size: 0.85em;"}

- Computational problem $F$ is in PolyCheck if polytime verifier exists
- Verifier can use hint $H$ to make verification efficient
- Examples include many classic hard problems
- **Question**: How does this relate to nondeterminism?

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

{{< iconify fa6-solid gears >}}  Can you intuitively grasp the definition of
PolyCheck? Can you connect this to a non-deterministic Turing machine? Can you
guess the benefits?

:::

## Haystack analogy for PolyCheck

::: {.incremental style="margin-top: -0.25em; font-size: 0.825em;"}

- {{< iconify fa6-solid magnifying-glass >}} **Searching for needles**: Finding
factors among vast possibilities
- {{< iconify fa6-solid eye >}} **Recognizing needles**: Quickly verify if
something is a needle
- {{< iconify fa6-solid circle-check >}} **PolyCheck problems**: Can efficiently
verify needles when found
- {{< iconify fa6-solid explosion >}} **Exponential haystack**: More
possibilities than atoms in universe
- {{< iconify fa6-solid lightbulb >}} **Key point**: Verification is not as
"costly" as discovery

:::

::: {.fragment .fade .boxed-content style="font-size: 0.9em;"}

**Finding versus verifying are different tasks**: for a 10,000-digit number,
there are vastly more non-factors than atoms in the observable universe.
PolyCheck means we can glance at a candidate and quickly determine if it's a
factor, without searching the entire space! See the benefits? Now, let's define
the NPoly class!

:::

# NPoly: nondeterministic polynomial time

::: {.incremental style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid code-branch >}} **NPoly**: Solved by nondeterministic
programs in polynomial time
- {{< iconify fa6-solid clock >}} **Nondeterministic running time**: Time until
last thread completes
- {{< iconify fa6-solid rocket >}} **Parallel search**: Launch thread for each
possible solution
- {{< iconify fa6-solid lightbulb >}} **Key idea**: Check all candidates
simultaneously in parallel

:::

::: {.fragment .fade .boxed-content style="font-size: 0.7em;"}

**NPoly uses parallel computation**: imagine launching a separate thread for
every possible solution and checking them "all at once" in a parallel fashion.
Intuitively, if the longest thread runs in polynomial time, the problem is in
NPoly!

:::

## Nondeterministic running time

![](12-polycheck-and-npoly_10.png)

::: {.fragment style="font-size: 0.85em;"}

- **Definition**: Maximum steps from root to any leaf in computation tree
- **Parallel perspective**: All threads run simultaneously
- **Polynomial bound**: All threads must finish in $O(n^k)$ time
- **Key**: Count steps in longest thread, not total across all threads
- **Important questions**:
    - What problems are in NPoly?
    - How does this relate to PolyCheck?

:::

## FACTOR is in NPoly

::: {.incremental style="margin-top: -0.25em; font-size: 0.85em;"}

- {{< iconify fa6-solid code-branch >}} **Nondeterministic approach**: Launch
thread for each possible factor
- {{< iconify fa6-solid calculator >}} **Number of threads**: $O(M) = O(10^n)$
for $n$-digit number
- {{< iconify fa6-solid tree >}} **Binary tree**: Each thread launches at most
two children
- {{< iconify fa6-solid ruler >}} **Tree depth**: $O(\log M) =
O(n)$ levels deep
- {{< iconify fa6-solid stopwatch >}} **Each thread**: Checks one factor in
$O(n^2)$ time (due to division)
- {{< iconify fa6-solid rocket >}} **Total nondeterministic time**: $O(n) \times
O(n^2) = O(n^3)$

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Exponentially many threads, polynomial time**: although we launch $O(10^n)$
threads, they're organized in a binary tree of depth $O(n)$. Each path from
root to leaf takes polynomial time, so FACTOR is in NPoly!

:::

# The remarkable result: PolyCheck = NPoly

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"}

- {{< iconify fa6-solid equals >}} **Main theorem**: PolyCheck and NPoly are
identical
- {{< iconify fa6-solid lightbulb >}} **Surprising**: Two completely different
definitions!
    - PolyCheck: Can verify solutions in polynomial time
    - NPoly: Can solve with nondeterministic polynomial time
- {{< iconify fa6-solid microscope >}} **Proof strategy**: Show mutual
containment
    - Part 1: PolyCheck $\subseteq$ NPoly
    - Part 2: NPoly $\subseteq$ PolyCheck
- {{< iconify fa6-solid rocket >}} **Implication**: Verification and
nondeterminism are equivalent!

:::

# Efficient verification or nondeterministic solving is the same complexity class!

::: fragment

- **PolyCheck**: Problems with efficient verification
- **NPoly**: Problems solvable with non-determinism

:::

## Key result summary

![](12-polycheck-and-npoly_11.png)

::: {.fragment style="font-size: 0.85em;"}

- **Claim 1**: Every NPoly problem is in PolyCheck
- **Claim 2**: Poly is a subset of PolyCheck/NPoly
- **Claim 3**: PolyCheck/NPoly is a subset of Expo

:::

# Middle ground: PolyCheck/NPoly

::: {.incremental style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid layer-group >}} **Hierarchy**: Poly $\subseteq$
PolyCheck/NPoly $\subseteq$ Expo
- {{< iconify fa6-solid arrow-right >}} **First inclusion**: Every Poly
problem is in PolyCheck/NPoly
    - Easy to verify by just solving and comparing!
- {{< iconify fa6-solid arrow-right >}} **Second inclusion**: Every
PolyCheck/NPoly problem is in Expo
    - Can solve by trying all possible solutions (exponential time)
- {{< iconify fa6-solid question >}} **Open questions**: Are these proper
subsets?
    - Is Poly $\subset$ PolyCheck/NPoly?
    - Is PolyCheck/NPoly $\subset$ Expo?

:::

## Decision problem relationships

![](12-polycheck-and-npoly_12.png)

::: {.fragment style="font-size: 0.85em;"}

- **Known**: Poly $\subseteq$ PolyCheck/NPoly $\subseteq$ Expo
- **Known**: Poly $\subset$ Expo (proper subset)
- **Unknown**: Are all these individual inclusions proper?
- **This diagram holds for decision problems only**

:::

## Key slogan about nondeterminism

::: {.fragment .boxed-content style="font-size: 0.95em;"}

{{< iconify fa6-solid quote-left >}} **Nondeterminism does not alter
computability, but it is widely believed to improve computational efficiency.**
{{< iconify fa6-solid quote-right >}}

:::

::: {.fragment style="margin-top: 0.5em; font-size: 0.875em;"}

- **Computability**: Nondeterminism does not enhance computability
- **Efficiency**: Nondeterminism likely adds exponential speedup
- **Open problem**: Proving this rigorously is extremely difficult
- **Importance**: Understanding this boundary drives complexity theory
- **Key beliefs that are as yet unproven**:
    - P $\neq$ NP
    - NP $\neq$ Exp

:::

## Complexity class relationships

![](12-polycheck-and-npoly_13.png)

::: {.fragment style="font-size: 0.85em;"}

- **P**: Decision problems in Poly
- **NP**: Decision problems in NPoly (equivalent to PolyCheck)
- **Exp**: Decision problems in Expo
- **Relationships**: Can you identify key relationships in this figure?

:::

## Key insights for proofgrammers

::: {.incremental style="margin-top: -0.25em; font-size: 0.85em;"}

- {{< iconify fa6-solid check-circle >}} **Verifiers**: Formalize "easy
to check" for solutions
- {{< iconify fa6-solid check-circle >}} **PolyCheck**: Problems with
polytime verification
- {{< iconify fa6-solid check-circle >}} **NPoly**: Problems with
nondeterministic polytime solutions
- {{< iconify fa6-solid check-circle >}} **Equivalence**: PolyCheck =
NPoly (remember, this is proven!)
- {{< iconify fa6-solid check-circle >}} **Sandwich**: Poly $\subseteq$
PolyCheck/NPoly $\subseteq$ Expo
- {{< iconify fa6-solid check-circle >}} **P versus NP**: Is Poly $\subset$
PolyCheck/NPoly?

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Understanding verification unlocks complexity theory**: PolyCheck/NPoly
captures problems where solutions are hard to find but easy to verify. This
class sits between Poly and Expo, leading to the most famous open question
in computer science! We will explore more details soon! Stay tuned!

:::
