---
title: "PolyCheck and NPoly"
description: "Grasp the benefits of verification"
date: "2025-11-17"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Learning objectives

::: {.fragment .callout-note icon=true title="Learning Objectives for Theoretical Machines"}

- **CS-204-1**: Use both intuitive analysis and theoretical proof
techniques to correctly distinguish between problems that are tractable,
intractable, and uncomputable.
- **CS-204-2**: Correctly use one or more variants of the Turing machine
(TM) abstraction to both describe and analyze the solution to a
computational problem.
- **CS-204-3**: Correctly use one or more variants of the finite state
machine (FSM) abstraction to describe and analyze the solution to a
computational problem.
- **CS-204-4**: Use a formal proof technique to correctly classify a
problem according to whether or not it is in the P, NP, NP-Hard, and/or
NP-Complete complexity class(es).
- **CS-204-5**: Apply insights from theoretical proofs concerning the
limits of either program feasibility or complexity to the implementation
of both correct and efficient real-world Python programs.

:::

## Key insights for proofgrammers

::: {.incremental style="margin-top: -0.25em; font-size: 0.875em;"}

- {{< iconify fa6-solid check-circle >}} **Poly and Expo**: fundamental
complexity classes
- {{< iconify fa6-solid check-circle >}} **Boundary matters**: small problem
changes shift complexity
- {{< iconify fa6-solid check-circle >}} **Tractability**: Poly captures
efficiently solvable problems
- {{< iconify fa6-solid check-circle >}} **Open questions**: many problems'
complexity unknown
- {{< iconify fa6-solid check-circle >}} **Proofgrammer skill**: recognize
complexity boundaries
- {{< iconify fa6-solid check-circle >}} **Foundation**: sets the stage for the
"P versus NP" question!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Understanding Poly and Expo is essential**: these complexity classes help
proofgrammers reason about computational feasibility and guide algorithm
design. Later, we'll explore NP and the famous "P versus NP" question!

:::
