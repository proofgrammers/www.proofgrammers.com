---
title: "Poly and Expo Classes"
description: "Explore the boundaries of complexity"
date: "2025-11-10"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Learning objectives

::: {.fragment .callout-note icon=true title="Learning Objectives for Theoretical Machines"}

- **CS-204-1**: Use both intuitive analysis and theoretical proof
techniques to correctly distinguish between problems that are tractable,
intractable, and uncomputable.
- **CS-204-2**: Correctly use one or more variants of the Turing machine
(TM) abstraction to both describe and analyze the solution to a
computational problem.
- **CS-204-3**: Correctly use one or more variants of the finite state
machine (FSM) abstraction to describe and analyze the solution to a
computational problem.
- **CS-204-4**: Use a formal proof technique to correctly classify a
problem according to whether or not it is in the P, NP, NP-Hard, and/or
NP-Complete complexity class(es).
- **CS-204-5**: Apply insights from theoretical proofs concerning the
limits of either program feasibility or complexity to the implementation
of both correct and efficient real-world Python programs.

:::

# Poly and Expo are two key complexity classes!

::: {.fragment .boxed-content style="font-size: 0.825em;"}

{{< iconify fa6-solid layer-group >}} **Poly and Expo** help with learning
objectives **CS-204-1** and **CS-204-4**. We will formally define these two
critical complexity classes and **explore their boundary**. One thing we will
learn is that small changes to problem definitions can dramatically shift
complexity. **As proofgrammers, let's explore the distinction between tractable
and intractable problems with both formal definitions and Python code**. Let's
dive into the details!

:::

## Vast gulf between growth rates

![Growth rate comparison](10-complexity-theory-basics_0.png)

::: fragment

- **Insight**: Wow, these growth rates differ dramatically!
- **Insight**: Polynomial growth is feasible, exponential is not!

:::

## Exponential versus polynomial

::: {.incremental style="margin-top: -0.25em; font-size: 0.9em;"}

- **Polynomial time**: $n$, $n^2$, $n^3$, $n^{100}$ (i.e., broadly tractable)
- **Exponential time**: $2^n$, $3^n$, $n!$ (i.e., intractable for large $n$)
- **Key insight**: Polynomial is feasible, exponential is not
- **Numerical Example**: $2^{100} \approx 10^{30}$ versus $100^2 = 10,000$
- **Cryptography**: Security relies on exponential-time attacks

:::

::: {.fragment .boxed-content .fade style="font-size: 0.825em;"}

- Polynomial-time problems are considered "efficiently computable"
- Exponential-time problems are generally "computationally impractical"
- {{< iconify fa6-solid rocket >}} **The polynomial/exponential
boundary demarcates tractability**

:::

## Poly formalizes polynomial-time

::: {.incremental style="margin-top: -0.25em; font-size: 0.875em;"}

- {{< iconify fa6-solid circle-check >}} **Poly**: problems solvable in
polynomial time
- {{< iconify fa6-solid calculator >}} **Definition**: program runs in
$O(n^k)$ for some constant $k$
- {{< iconify fa6-solid rocket >}} **Examples**: `containsGAGA`,
`multiply`, and `sortWords`
- {{< iconify fa6-solid lightbulb >}} **Key insight**: polynomial growth
is feasible for large inputs
- {{< iconify fa6-solid microscope >}} **Tractable**: Poly problems
considered efficiently solvable

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Poly captures tractable computation**: algorithms with polynomial running time
scale reasonably with input size. A problem in **Poly** can be solved
efficiently, making it practical for real-world applications! Wait, can you
think of any circumstance in which a **Poly** algorithm might not be practical?

:::

## Formal definition of Poly

![Poly definition](11-poly-and-expo_0.png)

::: fragment

- Assume we already know this problem is computable
- Computational problem $L$ is in **Poly** if solvable in polynomial time with
a computable method
- For some constant $k$, program runs in $O(n^k)$ time
- **Proofgrammers often want polynomial-time algorithms**!

:::

## Expo captures exponential-time

::: {.incremental style="margin-top: -0.25em; font-size: 0.875em;"}

- {{< iconify fa6-solid explosion >}} **Expo**: problems solvable in
exponential time
- {{< iconify fa6-solid calculator >}} **Definition**: program runs in
$O(2^{n^k})$ for some constant $k$
- {{< iconify fa6-solid rocket >}} **Examples**: all Poly problems, plus
`factor` and `MCopiesOfC`
- {{< iconify fa6-solid clock >}} **Key insight**: exponential growth
is infeasible for large inputs
- {{< iconify fa6-solid microscope >}} **Contains Poly**: every
polynomial-time problem is also in Expo

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Expo includes intractable problems**: algorithms with exponential running time
become impractical as input grows. A problem in **Expo** but not **Poly** is
considered computationally intractable! Wait, is there any case in which we
would prefer an **Expo** over a **Poly** algorithm? Can you explain why?

:::

## Formal definition of Expo

![Expo definition](11-poly-and-expo_1.png)

::: fragment

- Computational problem $L$ is in **Expo** if solvable in exponential time
- For some constant $k$, program runs in $O(2^{n^k})$ time
- **Important**: Poly $\subseteq$ Expo since polynomial is faster!

:::

# Poly is a subset of Expo

![Containment relationship](11-poly-and-expo_2.png)

::: {.fragment style="font-size: 0.875em;"}

- **Key relationship**: Poly $\subseteq$ Expo
- Every polynomial-time algorithm is also exponential-time
- But not every exponential-time problem has a polynomial solution!
- Some books refer to Poly as **FP** (function polynomial)

:::

## Examples contrasting complexity

::: {.incremental style="margin-top: -0.25em; font-size: 0.9em;"}

- {{< iconify fa6-solid check >}} **All3Sets**: generate all 3-element
subsets (polynomial)
- {{< iconify fa6-solid explosion >}} **AllSubsets**: generate all
subsets (exponential)
- {{< iconify fa6-solid route >}} **ShortestPath**: find shortest path
in graph (polynomial)
- {{< iconify fa6-solid map >}} **TSP**: find shortest Hamilton cycle
(exponential, currently)
- {{< iconify fa6-solid lightbulb >}} **Insight**: small problem changes
yield dramatic complexity shifts!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Subtle distinctions matter**: asking for "all 3-element subsets" versus
"all subsets" changes complexity from polynomial to exponential. Similarly,
"shortest path" versus "shortest Hamilton cycle" crosses the Poly/Expo
boundary!

:::

# Explore All3Sets versus AllSubsets

::: {.incremental style="margin-top: -0.5em; font-size: 0.875em;"}

- {{< iconify fa6-solid cubes >}} **All3Sets**: given set $S$, return all
3-element subsets
- {{< iconify fa6-solid layer-group >}} **AllSubsets**: given set $S$,
return all subsets
- {{< iconify fa6-solid calculator >}} **Counting**: for $n$ elements,
$\binom{n}{3}$ vs $2^n$ subsets
- {{< iconify fa6-solid rocket >}} **Complexity**: $O(n^3)$ vs $O(2^n)$
- {{< iconify fa6-solid microscope >}} **Boundary**: polynomial vs
exponential growth!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Exponential explosion**: with 10 elements, All3Sets generates 120
subsets while AllSubsets generates 1024. With 20 elements: 1140 vs over
1 million! **The difference becomes astronomical quickly**!

:::

## All3Sets problem definition

![All3Sets specification](11-poly-and-expo_3.png)

::: {.fragment style="font-size: 0.85em;"}

- Given set $S$ with $n$ elements, return all 3-element subsets
- Output formatted as set of sets with $\binom{n}{3} = O(n^3)$ subsets

:::

## AllSubsets problem definition

![AllSubsets specification](11-poly-and-expo_4.png)

::: {.fragment style="font-size: 0.85em;"}

- Given set $S$ with $n$ elements, return all possible subsets
- Output contains $2^n$ subsets, exponential growth in input size

:::

## Run `all3Sets` in Python {transition="convex"}

```{pyodide}
#| autorun: true
#| max-lines: 11
def all3Sets(inString):
    """Generate all subsets of size 3 from input set."""
    elems = inString.split()
    threeSets = []
    for i in range(0, len(elems)):
        for j in range(i+1, len(elems)):
            for k in range(j+1, len(elems)):
                this3Set = [elems[i], elems[j], elems[k]]
                threeSets.append(this3Set)
    result = ' '.join(['{' + ','.join(s) + '}' for s in threeSets])
    return result if result else ''

# test cases
print(f"all3Sets('') = '{all3Sets('')}'")
print(f"all3Sets('4 5 6') = '{all3Sets('4 5 6')}'")
print(f"all3Sets('4 5 6 7') = '{all3Sets('4 5 6 7')}'")
```

::: {.fragment style="font-size: 0.875em;"}

- **Analysis**: three nested loops, each iterates at most $n$ times
- **Time complexity**: $O(n^3)$ or cubic time, in Poly!

:::

## Run `allSubsets` in Python {transition="convex"}

```{pyodide}
#| autorun: true
#| max-lines: 10
def allSubsets(inString):
    """Generate all subsets from input set."""
    elems = inString.split()
    theSubsets = [[]]
    for element in elems:
        newSets = []
        for thisSet in theSubsets:
            newSets.append(thisSet + [element])
        theSubsets.extend(newSets)
    result = ' '.join(['{' + ','.join(s) + '}' for s in theSubsets])
    return result

# test cases
print(f"allSubsets('') = '{allSubsets('')}'")
print(f"allSubsets('4') = '{allSubsets('4')}'")
print(f"allSubsets('4 5 6') = '{allSubsets('4 5 6')}'")
```

::: {.fragment style="font-size: 0.875em;"}

- **Analysis**: doubles number of subsets for each element
- **Time complexity**: $O(2^n)$ or exponential time, in Expo but not Poly!

:::

# Explore graph path problems

::: {.incremental style="margin-top: -0.5em; font-size: 0.875em;"}

- {{< iconify fa6-solid route >}} **ShortestPath**: find shortest path
between two vertices
- {{< iconify fa6-solid map >}} **TSP**: find shortest Hamilton cycle
visiting all vertices
- {{< iconify fa6-solid calculator >}} **Algorithms**: Bellman-Ford
$O(n^2)$ vs brute force $O(n!)$
- {{< iconify fa6-solid rocket >}} **Complexity**: polynomial vs
exponential (no known poly algorithm)
- {{< iconify fa6-solid microscope >}} **Insight**: adding "visit all
vertices" constraint changes everything!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Hamilton cycle constraint is expensive**: requiring a path to visit every
vertex exactly once transforms a tractable problem into an intractable one.
TSP is a famous problem in Expo with no known polynomial algorithm!

:::

## ShortestPath problem definition

![ShortestPath specification](11-poly-and-expo_5.png)

::: {.fragment style="font-size: 0.85em;"}

- Find shortest path between two vertices in weighted graph
- Solvable in polynomial time using Bellman-Ford algorithm

:::

## TSPPath problem definition

![TSPPath specification](11-poly-and-expo_6.png)

::: {.fragment style="font-size: 0.85em;"}

- Find shortest path visiting all vertices exactly once
- No known polynomial algorithm for general case

:::

## TSP problem definition

![TSP specification](11-poly-and-expo_7.png){.sensible-size-thick-border}

::: {.fragment style="font-size: 0.85em;"}

- Find shortest Hamilton cycle in weighted graph
- Must visit all vertices exactly once and return to start

:::

## Visualize TSP complexity

![TSP example graph](11-poly-and-expo_8.png)

::: {.fragment style="font-size: 0.875em;"}

- Finding shortest Hamilton cycle requires checking many possibilities
- No known polynomial-time algorithm for general TSP
- **Question**: is TSP in Poly? This remains unknown!

:::

## Compare path and cycle

![Path versus cycle visualization](11-poly-and-expo_9.png)

::: {.fragment style="font-size: 0.875em;"}

- **ShortestPath**: efficient Bellman-Ford algorithm, $O(n^2)$
- **TSP**: no known polynomial algorithm, requires exponential search
- Small change in problem specification, huge complexity difference!

:::

# The boundary between Poly and Expo

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid ruler-combined >}} **Subtle distinctions**: small
problem changes dramatically alter complexity
- {{< iconify fa6-solid cubes >}} **All3Sets vs AllSubsets**: fixed size
vs all sizes
- {{< iconify fa6-solid route >}} **ShortestPath vs TSP**: any path vs
Hamilton cycle
- {{< iconify fa6-solid microscope >}} **Key lesson**: problem
constraints matter enormously
- {{< iconify fa6-solid lightbulb >}} **Proofgrammer skill**: recognize
when constraints push problems across boundary!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Understanding the Poly/Expo boundary is crucial**: as proofgrammers,
we must recognize which problem variations are tractable and which are not.
This guides algorithm design and problem formulation!

:::

## Decision problems in Expo but not Poly

::: {.incremental style="margin-top: -0.25em; font-size: 0.875em;"}

- {{< iconify fa6-solid question >}} **Open question**: are there problems
provably in Expo but not Poly?
- {{< iconify fa6-solid lock >}} **Difficulty**: proving lower bounds is
extremely hard
- {{< iconify fa6-solid microscope >}} **HaltEx**: artificial problem
in Expo but not Poly
- {{< iconify fa6-solid clock >}} **Constructed**: designed specifically
to require exponential time
- {{< iconify fa6-solid rocket >}} **Insight**: we can build
exponential-time problems!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Proving separations is difficult**: while we believe many problems require
exponential time, proving it rigorously is one of the deepest challenges in
theoretical computer science. HaltEx is an artificial construction!

:::

## HaltEx problem definition

![HaltEx specification](11-poly-and-expo_10.png)

::: {.fragment style="font-size: 0.825em;"}

- **HaltEx**: does program $P$ halt in exactly $M$ steps on input $I$?
- **Input encoding**: number $M$ can be unary (size $M$) or binary
(size $\log M$)
- **Unary encoding**: $M$ represented as string of $M$ ones, input
size equals value
- **Binary encoding**: $M$ represented in binary, input size is $\log M$
- **Key insight**: encoding choice dramatically affects complexity analysis!
- Artificial problem designed to demonstrate Poly/Expo separation

:::

## HaltEx upper bound analysis

![HaltEx is in Expo](11-poly-and-expo_11.png)

::: fragment

- Can simulate program for $M$ steps
- Input size is $M$ (unary), so this is $O(M) = O(n)$ steps
- Wait, that looks polynomial, not exponential! What's happening?

:::

## HaltEx complexity analysis

![HaltEx complexity details](11-poly-and-expo_12.png)

::: {.fragment style="font-size: 0.875em;"}

- **Critical detail**: each simulation step may take polynomial time
- If each step is $O(n^k)$, total is $O(M \times n^k) = O(n^{k+1})$
- This is polynomial in $n$, so actually HaltEx is in Poly!
- **The book's example uses binary encoding to make it exponential**

:::

## Alternative HaltEx analysis

![HaltEx with binary encoding](11-poly-and-expo_13.png)

::: {.fragment style="font-size: 0.875em;"}

- With binary encoding: $n = \log M$, so $M = 2^n$
- Simulating $M$ steps requires $O(2^n)$ time
- This is exponential in input size $n$!
- **Encoding matters for complexity analysis**!

:::

## HaltEx lower bound

![HaltEx not in Poly](11-poly-and-expo_14.png)

::: {.fragment style="font-size: 0.875em;"}

- **Proof sketch**: any correct program must simulate at least $M$ steps
- With binary encoding, $M = 2^n$, requiring exponential time
- Therefore, HaltEx is in Expo but not in Poly!
- This is an artificial example, but it proves the separation exists

:::

# Why study Poly?

::: {.incremental style="margin-top: -0.5em; font-size: 0.875em;"}

- {{< iconify fa6-solid graduation-cap >}} **Tractability**: Poly problems
generally feasible in practice
- {{< iconify fa6-solid equals >}} **Model independence**: Poly invariant
across computational models
- {{< iconify fa6-solid layer-group >}} **Foundation**: leads to
NP-completeness theory
- {{< iconify fa6-solid microscope >}} **Structure**: polynomial
algorithms have special mathematical properties
- {{< iconify fa6-solid lightbulb >}} **Caveat**: not all Poly algorithms
practical (e.g., $O(n^{100})$)!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Poly is the gold standard for efficiency**: while not perfect (some
polynomial algorithms are slow), Poly captures the essence of tractable
computation. It's the foundation for understanding computational limits!

:::

## Poly provides model independence

::: {.incremental style="margin-top: -0.25em; font-size: 0.9em;"}

- {{< iconify fa6-solid computer >}} **Different models**: Turing
machines, Python, Java, C++
- {{< iconify fa6-solid equals >}} **Polynomial equivalence**: models
simulate each other with polynomial overhead
- {{< iconify fa6-solid check >}} **Robust definition**: Poly remains
consistent across models
- {{< iconify fa6-solid rocket >}} **Exception**: quantum computers may
break this equivalence
- {{< iconify fa6-solid lightbulb >}} **Insight**: Poly is a fundamental
complexity class!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.775em;"}

**Model independence is powerful**: whether we analyze algorithms on Turing
machines, Python programs, or real computers, Poly remains the same class.
This mathematical robustness makes it the right abstraction for tractability!

:::

## Key insights for proofgrammers

::: {.incremental style="margin-top: -0.25em; font-size: 0.875em;"}

- {{< iconify fa6-solid check-circle >}} **Poly and Expo**: fundamental
complexity classes
- {{< iconify fa6-solid check-circle >}} **Boundary matters**: small
problem changes shift complexity
- {{< iconify fa6-solid check-circle >}} **Tractability**: Poly captures
efficiently solvable problems
- {{< iconify fa6-solid check-circle >}} **Open questions**: many
problems' complexity unknown
- {{< iconify fa6-solid check-circle >}} **Proofgrammer skill**: recognize
complexity boundaries
- {{< iconify fa6-solid check-circle >}} **Foundation**: sets stage for
P vs NP question!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Understanding Poly and Expo is essential**: these complexity classes help
proofgrammers reason about computational feasibility and guide algorithm
design. Next, we'll explore NP and the famous P vs NP question!

:::
