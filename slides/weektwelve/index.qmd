---
title: "Poly and Expo Classes"
description: "Explore the boundaries of complexity"
date: "2025-11-10"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Learning objectives

::: {.fragment .callout-note icon=true title="Learning Objectives for Theoretical Machines"}

- **CS-204-1**: Use both intuitive analysis and theoretical proof
techniques to correctly distinguish between problems that are tractable,
intractable, and uncomputable.
- **CS-204-2**: Correctly use one or more variants of the Turing machine
(TM) abstraction to both describe and analyze the solution to a
computational problem.
- **CS-204-3**: Correctly use one or more variants of the finite state
machine (FSM) abstraction to describe and analyze the solution to a
computational problem.
- **CS-204-4**: Use a formal proof technique to correctly classify a
problem according to whether or not it is in the P, NP, NP-Hard, and/or
NP-Complete complexity class(es).
- **CS-204-5**: Apply insights from theoretical proofs concerning the
limits of either program feasibility or complexity to the implementation
of both correct and efficient real-world Python programs.

:::

# Poly and Expo are two key complexity classes!

::: {.fragment .boxed-content style="font-size: 0.825em;"}

{{< iconify fa6-solid layer-group >}} **Poly and Expo** help with learning
objectives **CS-204-1** and **CS-204-4**. We will formally define these two
critical complexity classes and **explore their boundary**. One thing we will
learn is that small changes to problem definitions can dramatically shift
complexity. **As proofgrammers, let's explore the distinction between tractable
and intractable problems with both formal definitions and Python code**. Let's
dive into the details!

:::

## Vast gulf between growth rates

![Growth rate comparison](10-complexity-theory-basics_0.png)

::: fragment

- **Insight**: Wow, these growth rates differ dramatically!
- **Insight**: Polynomial growth is feasible, exponential is not!

:::

## Exponential versus polynomial

::: {.incremental style="margin-top: -0.25em; font-size: 0.9em;"}

- **Polynomial time**: $n$, $n^2$, $n^3$, $n^{100}$ (i.e., broadly tractable)
- **Exponential time**: $2^n$, $3^n$, $n!$ (i.e., intractable for large $n$)
- **Key insight**: Polynomial is feasible, exponential is not
- **Numerical Example**: $2^{100} \approx 10^{30}$ versus $100^2 = 10,000$
- **Cryptography**: Security relies on exponential-time attacks

:::

::: {.fragment .boxed-content .fade style="font-size: 0.825em;"}

- Polynomial-time problems are considered "efficiently computable"
- Exponential-time problems are generally "computationally impractical"
- {{< iconify fa6-solid rocket >}} **The polynomial/exponential
boundary demarcates tractability**

:::

## Poly formalizes polynomial-time

::: {.incremental style="margin-top: -0.25em; font-size: 0.875em;"}

- {{< iconify fa6-solid circle-check >}} **Poly**: problems solvable in
polynomial time
- {{< iconify fa6-solid calculator >}} **Definition**: program runs in
$O(n^k)$ for some constant $k$
- {{< iconify fa6-solid rocket >}} **Examples**: `containsGAGA`,
`multiply`, and `sortWords`
- {{< iconify fa6-solid lightbulb >}} **Key insight**: polynomial growth
is feasible for large inputs
- {{< iconify fa6-solid microscope >}} **Tractable**: Poly problems
considered efficiently solvable

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Poly captures tractable computation**: algorithms with polynomial running time
scale reasonably with input size. A problem in **Poly** can be solved
efficiently, making it practical for real-world applications! Wait, can you
think of any circumstance in which a **Poly** algorithm might not be practical?

:::

## Formal definition of Poly

![Poly definition](11-poly-and-expo_0.png)

::: fragment

- Assume we already know problem $L$ is computable
- Computational problem $L$ is in **Poly** if solvable in polynomial time with
a computable method
- For some constant $k$, program runs in $O(n^k)$ time
- **Proofgrammers often want polynomial-time algorithms**!

:::

## Expo captures exponential-time

::: {.incremental style="margin-top: -0.25em; font-size: 0.875em;"}

- {{< iconify fa6-solid explosion >}} **Expo**: problems solvable in
exponential time
- {{< iconify fa6-solid calculator >}} **Definition**: program runs in
$O(2^{n^k})$ for some constant $k$
- {{< iconify fa6-solid rocket >}} **Examples**: all Poly problems, plus
`factor` and `MCopiesOfC`
- {{< iconify fa6-solid clock >}} **Key insight**: exponential growth
is infeasible for large inputs
- {{< iconify fa6-solid microscope >}} **Contains Poly**: every
polynomial-time problem is also in Expo

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Expo includes intractable problems**: algorithms with exponential running time
become impractical as input grows. A problem in **Expo** but not **Poly** is
considered computationally intractable! Wait, is there any case in which we
would prefer an **Expo** over a **Poly** algorithm? Can you explain why?

:::

## Formal definition of Expo

![Expo definition](11-poly-and-expo_1.png)

::: {.fragment style="font-size: 0.95em;"}

- Assume we already know a problem $L$ is computable
- Computational problem $L$ is in **Expo** if it is computable and solvable in
exponential time
- For polynomial function $p(n)$, program runs in $O(2^{p(n)})$ time
- **Important**: Poly $\subseteq$ Expo since polynomial is faster!

:::

# Poly is a subset of Expo

![](11-poly-and-expo_2.png){.sensible-size-thick-border}

## Explore containment relationship

::: {.fragment style="font-size: 0.975em;"}

- {{< iconify fa6-solid lightbulb >}} **Key relationship to note**: Poly
$\subseteq$ Expo
- Every polynomial-time algorithm is also exponential-time
- Some books refer to Poly as **FP** (function polynomial)
- {{< iconify fa6-solid microscope >}} **Key questions to ask**:
    - What are the practical implications of this relationship?
    - What are the "hallmarks" of problems in these classes?
    - Can we "tweak" a problem to make it Poly instead of Expo?
    - Overall, what is the "boundary" between Poly and Expo?

:::

## Examples that contrast complexity

::: {.incremental style="margin-top: -0.25em; font-size: 0.9em;"}

- {{< iconify fa6-solid check >}} **All3Sets**: generate all 3-element subsets
(polynomial)
- {{< iconify fa6-solid explosion >}} **AllSubsets**: generate all subsets
(exponential)
- {{< iconify fa6-solid route >}} **ShortestPath**: find shortest path in graph
(polynomial)
- {{< iconify fa6-solid map >}} **TSP**: find shortest Hamilton cycle
(exponential, currently)
- {{< iconify fa6-solid lightbulb >}} **Insight**: small problem changes yield
dramatic complexity shifts!
- {{< iconify fa6-solid rocket >}} **Question**: ways to "tweak" problems to
make them tractable?

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Subtle distinctions matter**: asking for "all 3-element subsets" versus "all
subsets" changes complexity from polynomial to exponential. Also, "shortest
path" versus "shortest Hamilton cycle" crosses the Poly/Expo boundary!

:::

# All3Sets or AllSubsets?

::: {.incremental style="margin-top: -0.5em; font-size: 0.875em;"}

- {{< iconify fa6-solid cubes >}} **All3Sets**: given set $S$, return all
3-element subsets
- {{< iconify fa6-solid layer-group >}} **AllSubsets**: given set $S$,
return all subsets
- {{< iconify fa6-solid calculator >}} **Counting**: for $n$ elements,
$\binom{n}{3}$ vs $2^n$ subsets
- {{< iconify fa6-solid rocket >}} **Complexity**: $O(n^3)$ vs $O(2^n)$
- {{< iconify fa6-solid microscope >}} **Boundary**: polynomial vs
exponential growth!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Exponential explosion**: with 10 elements, All3Sets generates 120 subsets
while AllSubsets generates 1024. About the same, right? With 20 elements: 1140
vs over 1 million! **The difference becomes astronomical quickly**!

:::

## All3Sets problem definition

![All3Sets specification](11-poly-and-expo_3.png)

::: {.fragment style="margin-top: -0.15em; font-size: 0.85em;"}

- Given set $S$ with $n$ elements, return all 3-element subsets
- Output formatted as set of sets with $\binom{n}{3} = O(n^3)$ subsets

:::

## AllSubsets problem definition

![AllSubsets specification](11-poly-and-expo_4.png)

::: {.fragment style="margin-top: -0.2em; font-size: 0.68em;"}

- Given set $S$ with $n$ elements, return all possible subsets
- Output contains $2^n$ subsets, exponential growth in input size

:::

## Run `all3Sets` in Python {transition="convex"}

```{pyodide}
#| autorun: true
#| max-lines: 11
def all3Sets(inString):
    """Generate all subsets of size 3 from input set."""
    elems = inString.split()
    threeSets = []
    for i in range(0, len(elems)):
        for j in range(i+1, len(elems)):
            for k in range(j+1, len(elems)):
                this3Set = [elems[i], elems[j], elems[k]]
                threeSets.append(this3Set)
    result = ' '.join(['{' + ','.join(s) + '}' for s in threeSets])
    return result if result else ''

# test cases
print(f"all3Sets('') = '{all3Sets('')}'")
print(f"all3Sets('4 5 6') = '{all3Sets('4 5 6')}'")
print(f"all3Sets('4 5 6 7') = '{all3Sets('4 5 6 7')}'")
```

::: {.fragment style="font-size: 0.75em;"}

- **Analysis**: three nested loops, each iterates at most $n$ times
- **Time complexity**: $O(n^3)$ or cubic time, which means it is in Poly!

:::

## Run `allSubsets` in Python {transition="convex"}

```{pyodide}
#| autorun: true
#| max-lines: 10
def allSubsets(inString):
    """Generate all subsets from input set."""
    elems = inString.split()
    theSubsets = [[]]
    for element in elems:
        newSets = []
        for thisSet in theSubsets:
            newSets.append(thisSet + [element])
        theSubsets.extend(newSets)
    result = ' '.join(['{' + ','.join(s) + '}' for s in theSubsets])
    return result

# test cases
print(f"allSubsets('') = '{allSubsets('')}'")
print(f"allSubsets('4') = '{allSubsets('4')}'")
print(f"allSubsets('4 5 6') = '{allSubsets('4 5 6')}'")
```

::: {.fragment style="font-size: 0.875em;"}

- **Analysis**: doubles number of subsets for each element
- **Time complexity**: $O(2^n)$ or exponential time, in Expo but not Poly!

:::

# Graph path problems

::: {.incremental style="margin-top: -0.5em; font-size: 0.875em;"}

- {{< iconify fa6-solid route >}} **ShortestPath**: find shortest path
between two vertices
- {{< iconify fa6-solid map >}} **TSP**: find shortest Hamilton cycle
visiting all vertices
- {{< iconify fa6-solid calculator >}} **Algorithms**: Bellman-Ford
$O(n^2)$ vs brute force $O(n!)$
- {{< iconify fa6-solid rocket >}} **Complexity**: polynomial vs
exponential (no known poly algorithm)
- {{< iconify fa6-solid microscope >}} **Insight**: adding "visit all
vertices" constraint changes everything!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Hamilton cycle constraint is expensive**: requiring a path to visit every
vertex exactly once transforms a tractable problem into an intractable one. TSP
is a famous problem in Expo with no known polynomial algorithm! *At least, yet*!

:::

## Visualize an example graph

![](11-poly-and-expo_7.png){.sensible-square-thick-border}

::: {.fragment style="font-size: 0.75em;"}

- Find shortest Hamilton cycle in weighted graph
- Must visit all vertices exactly once and return to start

:::

## TSP problem definition

![TSP problem specification](11-poly-and-expo_5.png)

::: {.fragment style="margin-top: -0.25em; font-size: 0.85em;"}

- Can you decode the meaning of `a,b,3` or `b,c,1`?
- Focus on the connections between vertices and their weights
- Connects to the `TSPPath` and `ShortestPath` problems
- **Practical applications**: logistics, scheduling, DNA sequencing

:::

## TSPPath problem definition

![TSPPath specification](11-poly-and-expo_6.png)

::: {.fragment style="margin-top: -0.15em; font-size: 0.75em;"}

- **Goal**: Find shortest path visiting all vertices exactly once
- **Alarm**: No known polynomial algorithm for the general case!
- Currently, we have a $O(n!)$ brute-force search where $n! \in O(2^{n^2})$

:::

## ShortestPath problem definition

![ShortestPath specification](11-poly-and-expo_8.png)

::: {.fragment style="margin-top: -0.15em; font-size: 0.75em;"}

- When there are positive weights, solved by Dijkstra's algorithm
- This means that it is in $O(n^2)$ time, which is polynomial!
- **Aha, this means that ShortestPath is in Poly, while TSPPath is in Expo**!

:::

## Compare path and cycle

![Exploring complexity class membership that is "obvious"](11-poly-and-expo_9.png){.sensible-square-thick-border}

# Using a similar graph data structure, two algorithms have vastly different complexity!

::: {.fragment style="margin-top: -.2em; font-size: 0.875em;"}

- **ShortestPath**: use Dijkstra or Bellman-Ford algorithm at $O(n^2)$
- **TSP**: no known polynomial algorithm, requires exponential search
- **Small change in problem specification, huge complexity difference**!

:::

## The boundary between Poly and Expo

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid ruler-combined >}} **Subtle difference**: small problem
changes really alter complexity
- {{< iconify fa6-solid cubes >}} **All3Sets versus AllSubsets**: fixed size
versus all sizes
- {{< iconify fa6-solid route >}} **ShortestPath versus TSP**: any path versus
Hamilton cycle
- {{< iconify fa6-solid microscope >}} **Key lesson**: problem constraints
matter enormously
- {{< iconify fa6-solid lightbulb >}} **Proofgrammer skill**: recognize when
constraints push problems across boundary and try to "reel them back"!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Understanding the Poly/Expo boundary is crucial**: as proofgrammers, we must
first prove a problem computable and then recognize which problem variations are
tractable and which are not. This guides algorithm design and problem
formulation, with small "tweaks" changing tractability!

:::

## Problems in Expo but not Poly

::: {.incremental style="margin-top: -0.25em; font-size: 0.875em;"}

- {{< iconify fa6-solid question >}} **Open question**: are there problems
provably in Expo but not Poly?
- {{< iconify fa6-solid lock >}} **Difficulty**: proving lower bounds is
extremely hard
- {{< iconify fa6-solid microscope >}} **HaltEx**: artificial problem
in Expo but not Poly
    - Given program $P$ and input $I$, simulate $P$ on $I$ for $2^n$ steps
    - Requires at most an exponential nubmer of steps
    - This shows that Expo contains problems not in Poly
- {{< iconify fa6-solid clock >}} **Constructed**: designed specifically
to require exponential time

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

{{< iconify fa6-solid lightbulb >}} **Proving separations is difficult**: while
we believe many problems require exponential time, rigorous proof is
challenging, not all lower bounds known!

:::

# Why study Poly class?

::: {.incremental style="margin-top: -0.5em; font-size: 0.875em;"}

- {{< iconify fa6-solid graduation-cap >}} **Tractability**: Poly problems
generally feasible in practice
- {{< iconify fa6-solid equals >}} **Model independence**: Poly invariant
across computational models
- {{< iconify fa6-solid layer-group >}} **Foundation**: leads to
NP-completeness theory
- {{< iconify fa6-solid microscope >}} **Structure**: polynomial
algorithms have special properties
- {{< iconify fa6-solid lightbulb >}} **Caveat**: not all Poly algorithms
practical (e.g., $O(n^{100})$)!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Poly is the gold standard for efficiency**: while not perfect (i.e., some
polynomial algorithms are slow), Poly captures the essence of tractable
computation. It's the foundation for understanding computational limits!

:::

## Poly provides model independence

::: {.incremental style="margin-top: -0.25em; font-size: 0.9em;"}

- {{< iconify fa6-solid computer >}} **Different models**: Turing
machines, Python, Java, C++
- {{< iconify fa6-solid equals >}} **Polynomial equivalence**: models
simulate each other with "polynomial overhead", so Python as an "API" for a TM
- {{< iconify fa6-solid check >}} **Robust definition**: Poly remains
consistent across models
- {{< iconify fa6-solid rocket >}} **Exception**: quantum computers may
break this equivalence
- {{< iconify fa6-solid lightbulb >}} **Insight**: Poly is a fundamental
complexity class!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.775em;"}

**Model independence is powerful**: whether we analyze algorithms on Turing
machines, Python programs, or real computers, Poly remains the same class.
This mathematical robustness makes it the right abstraction for tractability!

:::

## Key insights for proofgrammers

::: {.incremental style="margin-top: -0.25em; font-size: 0.875em;"}

- {{< iconify fa6-solid check-circle >}} **Poly and Expo**: fundamental
complexity classes
- {{< iconify fa6-solid check-circle >}} **Boundary matters**: small problem
changes shift complexity
- {{< iconify fa6-solid check-circle >}} **Tractability**: Poly captures
efficiently solvable problems
- {{< iconify fa6-solid check-circle >}} **Open questions**: many problems'
complexity unknown
- {{< iconify fa6-solid check-circle >}} **Proofgrammer skill**: recognize
complexity boundaries
- {{< iconify fa6-solid check-circle >}} **Foundation**: sets the stage for the
"P versus NP question"!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Understanding Poly and Expo is essential**: these complexity classes help
proofgrammers reason about computational feasibility and guide algorithm
design. Later, we'll explore NP and the famous P vs NP question!

:::
